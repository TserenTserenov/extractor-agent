# Процессы Knowledge Extractor

> **Source-of-truth:** `DP.AISYS.013` (spf-digital-platform-pack)
> **Метод:** `DP.METHOD.001` (Экстракция знаний)
> **Рабочий продукт:** `DP.WP.001` (Отчёт экстракции)

---

## Обзор

Knowledge Extractor (KE) — ИИ-система с **5 процессами**, работающими по единому пайплайну: обнаружение → классификация → маршрутизация → формализация → валидация.

**Ключевое решение:** KE **не следит** за сессией в реальном времени. Он вызывается в конкретные моменты:

| Момент вызова | Процесс | Кто вызывает |
|---------------|---------|--------------|
| Закрытие сессии | Session-Close Extraction | Протокол Close (CLAUDE.md § 2) |
| Явная команда | On-Demand Extraction | Пользователь (`/extract`) |
| Загрузка документа | Bulk Extraction | Пользователь |
| Изменение в Pack | Cross-Repo Sync | Пользователь / триггер |
| По расписанию / запросу | Knowledge Audit | Расписание / пользователь |

> **Примитив capture-to-pack** (текущий «Capture: X → Y» в CLAUDE.md) — это НЕ KE. Это поведение Claude Code во время Work-протокола. KE формализует и проверяет то, что capture-to-pack только анонсирует.

---

## Процесс 1: Session-Close Extraction

> Главный процесс. Запускается при закрытии каждой рабочей сессии.

### Триггер

Пользователь говорит «закрываю сессию» / «всё» / РП завершён. Или протокол Close (CLAUDE.md § 2) включается автоматически.

### ВДВ (Вход → Действие → Выход)

**Входы:**

| Вход | Источник | Описание |
|------|----------|----------|
| Отложенные captures | Текущая сессия | Все анонсы «Capture: X → Y» за сессию |
| Контекст сессии | Транскрипт | Что делали, какие решения принимали |
| Манифесты Pack'ов | `00-pack-manifest.md` | Bounded context каждого Pack'а |
| Существующие сущности | Pack-директории | Для проверки дубликатов и назначения ID |

**Действия:**

```
1. Собрать отложенные captures из сессии
2. Просмотреть контекст сессии на пропущенные captures
3. Для каждого кандидата:
   3a. Классификация → тип знания (см. §Классификация)
   3b. Маршрутизация → целевой Pack + директория (см. §Маршрутизация)
   3c. Формализация → SPF-совместимый файл (см. §Формализация)
   3d. Валидация → проверка корректности (см. §Валидация)
4. Сформировать Extraction Report (DP.WP.001)
5. Показать пользователю для ревью
6. Применить одобренные (accept) кандидаты
7. Закоммитить изменения
```

**Выходы:**

| Выход | Формат | Получатель |
|-------|--------|------------|
| Extraction Report | Markdown (встроен в отчёт Close) | Пользователь |
| Pack-совместимые файлы | `.md` с frontmatter | Pack-репозитории |
| Коммиты | Git diff | Репозитории |

### Пример

```
Сессия: работа над ботом (РП4).
Во время сессии Claude анонсировал:
  - Capture: FSM-идемпотентность → spf-digital-platform-pack (FM)
  - Capture: Правило маршрутизации mode → aist_bot/CLAUDE.md (rule)

На Close KE:
1. Берёт 2 отложенных capture
2. Проверяет сессию — находит ещё 1 пропущенный:
   «Паттерн: handler-per-state вместо switch-case» → method
3. Для каждого:
   - FSM-идемпотентность → DP.FM.003-non-idempotent-state.md (accept)
   - Правило маршрутизации → aist_bot/CLAUDE.md, строка 42 (accept)
   - handler-per-state → DP.METHOD.002-handler-per-state.md (defer — нужна доп. информация)
4. Отчёт → пользователь ревьюит → 2 accept, 1 defer
5. Записывает 2 файла, коммитит
```

---

## Процесс 2: On-Demand Extraction

> Явный вызов в середине сессии для конкретного инсайта.

### Триггер

Пользователь явно говорит: «запиши это в Pack», «это нужно зафиксировать», `/extract [текст]`.

### ВДВ

**Входы:**

| Вход | Источник |
|------|----------|
| Конкретный инсайт | Слова пользователя или контекст |
| Pack-манифесты | `00-pack-manifest.md` |

**Действия:**

```
1. Классификация инсайта
2. Маршрутизация
3. Формализация (быстрая — один кандидат)
4. Валидация
5. Показать: «Предлагаю записать: {ID} {название} → {путь}»
6. Дождаться одобрения
7. Записать + коммитнуть (или отложить до Close)
```

**Выходы:** Один Pack-совместимый файл или запись в CLAUDE.md.

### Отличие от capture-to-pack

| Capture-to-pack (текущий) | On-Demand Extraction (KE) |
|---------------------------|---------------------------|
| Анонс: «Capture: X → Y» | Полная формализация: frontmatter + шаблон + ID |
| Не создаёт файл | Создаёт готовый файл |
| Классификация неявная | Классификация явная (тип знания) |
| Маршрутизация приблизительная | Маршрутизация точная (Pack + директория + ID) |

---

## Процесс 3: Bulk Extraction

> Обработка документа или набора документов.

### Триггер

Пользователь загружает документ: «обработай этот гайд», «извлеки знания из поста».

### ВДВ

**Входы:**

| Вход | Описание |
|------|----------|
| Исходный документ | Markdown, текст, пост, гайд, заметки |
| Pack-манифесты | Bounded contexts всех Pack'ов |
| Существующие сущности | Для проверки дубликатов |

**Действия:**

```
1. Прочитать исходный документ полностью
2. Идентифицировать все кандидаты на знание:
   - Различения (пары «A ≠ B»)
   - Методы (описания «как делать»)
   - Сущности (описания компонентов)
   - Failure modes (описания «чего не делать»)
   - Правила (операционные ограничения)
3. Для каждого кандидата: классификация → маршрутизация → формализация → валидация
4. Сформировать полный Extraction Report (DP.WP.001)
5. Показать пользователю для ревью
6. Применить одобренные кандидаты
```

**Выходы:**

| Выход | Формат |
|-------|--------|
| Extraction Report | Отдельный `.md` файл |
| Pack-совместимые файлы | Батч файлов с frontmatter |
| Коммиты | По одному на Pack |

### Пример

```
Вход: пост «DDD vs FPF/SPF/Pack» из Knowledge-Index.
KE находит:
  - 3 различения (DDD aggregate ≠ Pack entity, bounded context разный смысл, ...)
  - 1 метод (трансляция DDD-паттернов в SPF)
  - 2 failure modes (прямое применение DDD без адаптации, ...)
Отчёт: 6 кандидатов → пользователь ревьюит → 4 accept, 2 reject.
```

---

## Процесс 4: Cross-Repo Sync

> Проверка: изменение в Pack → нужно ли обновить downstream?
> Промпт: `prompts/cross-repo-sync.md`

### Триггер

Ручной запуск после изменения Pack-файла: «проверь синхронизацию», «sync downstream».

### ВДВ

**Входы:** Изменённые файлы Pack'а + список downstream-репо (из манифеста).

**Действия:**
1. Определить изменения в Pack (git log/diff)
2. Определить затронутые downstream-репо (по манифесту)
3. Для каждого downstream: проверить CLAUDE.md, промпты, PROCESSES.md
4. Сформировать Sync Report с конкретными расхождениями

**Выходы:** Sync Report со списком расхождений и предложениями обновления.

---

## Процесс 5: Knowledge Audit

> Периодическая ревизия Pack'ов: структура, полнота, качество.
> Промпт: `prompts/knowledge-audit.md`

### Триггер

По запросу: «аудит Pack», «audit». Рекомендуется: раз в месяц.

### ВДВ

**Входы:** Pack-репозитории (один, несколько или все).

**Действия:**
1. Структурная проверка: frontmatter, ID, обязательные секции, ссылки
2. Контентная проверка: пробелы, дубликаты, изоляция, баланс типов
3. Формирование Audit Report с оценкой (здоровый / требует внимания / критичный)

**Выходы:** Audit Report с рекомендациями и конкретными исправлениями.

---

## Общий пайплайн (детали шагов)

> Используется во всех процессах. Подробности каждого шага.

### Шаг 1: Обнаружение (Detection)

**Тест универсальности:** Можно ли использовать это знание в другом проекте/контексте?
- Да → кандидат на экстракцию
- Нет → это governance-контент (план, задача, статус) → не экстрагировать

**Что НЕ является знанием:**
- Статусы задач, планы, дедлайны → governance (my-strategy)
- Код → instrument-репо
- UI-текст → surface-репо
- Персональные данные пользователя → user-space

### Шаг 2: Классификация (Classification)

| Тип знания | Признак | Код типа |
|------------|---------|----------|
| Доменная сущность | Описывает компонент, архитектуру, состояние | `entity` |
| Различение | Пара «A ≠ B» с тестом проверки | `distinction` |
| Метод | Способ действия (как делать), IPO | `method` |
| Work Product | Тип артефакта (что получается на выходе) | `wp` |
| Failure Mode | Типовая ошибка (чего не делать) | `fm` |
| Правило | Операционное ограничение (1-3 строки) | `rule` |

### Шаг 3: Маршрутизация (Routing)

**Определение Pack'а по домену:**

| Домен знания | Целевой Pack | Префикс |
|--------------|-------------|---------|
| Платформа, ИТ, ИИ-системы | `spf-digital-platform-pack` | `DP` |
| Созидатель, развитие, индикаторы | `spf-personal-pack` | `PP` |
| Экосистема, клуб, программы | `spf-ecosystem-pack` | `EP` |

**Определение директории по типу знания:**

| Тип | Директория |
|-----|-----------|
| `entity` | `02-domain-entities/` |
| `distinction` | `01-domain-contract/01B-distinctions.md` (добавить секцию) |
| `method` | `03-methods/` |
| `wp` | `04-work-products/` |
| `fm` | `05-failure-modes/` |
| `rule` (глобальное) | `~/Github/CLAUDE.md` |
| `rule` (локальное) | `<repo>/CLAUDE.md` |
| `rule` (урок) | `memory/<topic>.md` |

### Шаг 4: Формализация (Formalization)

#### На основании чего KE формализует?

1. **Тип знания** → определяет шаблон SPF (какие секции нужны)
2. **Pack-манифест** → определяет bounded context и префикс кодов
3. **Существующие сущности** → определяют следующий ID и стиль написания

#### Именование файлов

**Конвенция:** `{PREFIX}.{TYPE}.{NNN}-{slug}.md`

| Компонент | Откуда берётся | Пример |
|-----------|----------------|--------|
| `PREFIX` | Pack-манифест (`Pack ID`) | `DP` |
| `TYPE` | Классификация (шаг 2) | `METHOD`, `FM`, `WP`, `AISYS`, `ARCH`, `NAV`, ... |
| `NNN` | Следующий номер (max существующий + 1) | `002` |
| `slug` | Kebab-case из названия кандидата | `handler-per-state` |

**Примеры:**
- `DP.METHOD.002-handler-per-state.md`
- `DP.FM.003-non-idempotent-state.md`
- `PP.WP.001-weekly-reflection.md`

**Алгоритм назначения ID:**
1. Прочитать целевую директорию Pack'а
2. Найти все файлы с паттерном `{PREFIX}.{TYPE}.*`
3. Взять максимальный номер NNN
4. Новый ID = NNN + 1

#### Шаблоны по типу знания

**Entity (доменная сущность):**
```yaml
---
id: {PREFIX}.{TYPE}.{NNN}
type: {тип-карточки}
status: draft
created: {YYYY-MM-DD}
trust:
  F: 2
  G: domain
  R: 0.3
epistemic_stage: emerging
---

# {Название}

## 1. Определение
{1-2 предложения}

## 2. {Секции по типу сущности}

## N. Связанные документы
- [{ID} {Название}](path) — {связь}
```

**Distinction (различение):**
```markdown
### D.{PREFIX}.{NNN}: {A} ≠ {B}

| {A} | {B} |
|-----|-----|
| {признак 1} | {признак 1} |
| {признак 2} | {признак 2} |

**Почему важно**: {1 предложение}

**Тест**: {вопрос}? Да → {A}. Нет → {B}.
```

**Method (метод):**
```yaml
# {Название метода}

## 1. Определение
## 2. Проблема
## 3. IPO-паттерн
| Элемент | Описание |
|---------|----------|
| Входы | ... |
| Обработка | ... |
| Выходы | ... |
## 4. Шаги метода
## 5. Связанные документы
```

**Failure Mode:**
```yaml
# FM: {Название ошибки}

## 1. Паттерн ошибки
## 2. Почему это ошибка
## 3. Антипаттерн → Паттерн
## 4. Тест обнаружения
## 5. Связанные документы
```

**Work Product:**
```yaml
# {Название рабочего продукта}

## 1. Определение
## 2. Назначение
## 3. Структура
## 4. Жизненный цикл
## 5. Связанные документы
```

### Шаг 5: Валидация (Validation)

**Чеклист перед предложением:**

- [ ] Есть ли frontmatter с id, type, status, trust? (иначе → FM.001)
- [ ] Размещён ли в правильной директории Pack? (по типу)
- [ ] Нет ли дубликата? (проверка по ID и по содержанию)
- [ ] Соответствует ли bounded context Pack'а? (проверка по манифесту)
- [ ] Есть ли ссылки на связанные сущности?
- [ ] Не является ли это governance-контентом? (тест: привязано к проекту/срокам?)
- [ ] Не нарушены ли SPF-запреты? (no "step", "lesson" в доменном контенте)

---

## Данные процессов

### Extraction Report (DP.WP.001)

Полная структура описана в `spf-digital-platform-pack/pack/digital-platform/04-work-products/DP.WP.001-extraction-report.md`.

**Краткая структура:**

```markdown
---
type: extraction-report
source: session | bulk | audit
date: YYYY-MM-DD
---

### Кандидат #N

- **Источник:** {откуда}
- **Сырой текст:** «{цитата}»
- **Классификация:** {тип}
- **Маршрут:** {Pack/директория/ID-slug.md}
- **Формализованный текст:** {готовый текст}
- **Вердикт:** accept | reject | defer
- **Причина:** {при reject/defer}

## Сводка

| Метрика | Значение |
|---------|----------|
| Всего кандидатов | N |
| Принято | N |
| Отклонено | N |
| Отложено | N |
```

### Вердикты

| Вердикт | Когда | Что дальше |
|---------|-------|------------|
| **accept** | Знание корректно, маршрут верен, формат OK | Записать в Pack |
| **reject** | Не знание, дубликат, governance-контент | Не записывать, объяснить |
| **defer** | Нужна доп. информация или экспертиза | Перенести в следующий цикл |

---

## Взаимодействие с другими протоколами

### KE + Протокол Close (CLAUDE.md § 2)

```
Протокол Close:
  1. Собрать отложенные captures ← КЕ: Session-Close Extraction (шаги 1-4)
  2. Предложить изменения        ← КЕ: Extraction Report
  3. Получить одобрение           ← КЕ: Human-in-the-loop
  4. Применить изменения          ← КЕ: Запись accept-кандидатов
  5. Обновить MEMORY.md           ← Протокол Close (не KE)
  6. Закоммитить                  ← КЕ: коммит Pack-изменений
```

### KE + Capture-to-Pack (CLAUDE.md § 2, Work)

Capture-to-Pack во время Work-протокола остаётся **примитивом**: Claude Code анонсирует «Capture: X → Y» при обнаружении знания на рубеже. KE на Close обрабатывает эти анонсы + ищет пропущенные.

**Порядок:**
1. Во время Work → capture-to-pack создаёт заметки (анонсы)
2. На Close → KE берёт заметки + сканирует сессию → полная формализация

---

*Последнее обновление: 2026-02-10*
